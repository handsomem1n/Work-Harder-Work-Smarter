#include <iostream>
#include <cmath>

using namespace std;

struct Point {      // 위의 구조체'struct'는 x와 y라는 두 개의 멤버 변수를 가지고 있음
  int x;
  int y;
};
                    // 이제 이 구조체를 사용하여 점 좌표를 저장할 수 있다. 
                    
int main() {
  Point p1 = { 3, 4 };
  Point p2 = { 6, 8 };
                    // 두 개의 Point 객체 p1, p2를 생성한 것임.
  
  int dx = p2.x - p1.x;
  int dy = p2.y - p1.y;
                    // 두 점 사이의 거리를 계산하기 위해 거리 공식을 사용한 것임.
                    // 구조체 멤버 변수에 접근할 때는 점 연산자 (.)를 사용한다. 예를 들어, p2.x는 p2라는 구조체 변수의 x 멤버 변수를 참조함.
                    /* ★p2 다음에 점 연산자 (.)를 사용하여 Point 구조체의 멤버 변수인 x를 참조하고 있다.
                       p2.x는 p2의 x값을 의미하며, p1.x는 p1의 x값을 의미함. -> 이 두 값을 빼면, x축 방향으로 두 점 사이의 거리 (dx)를 계산할 수 있다. */
  
  double distance = sqrt(dx * dx + dy * dy);
  
  cout << "The distance between the two points is: " << distance << endl;
  
  return 0;
}


// :: comment ::
/* 구조체는 일반적으로 정적 할당으로 생성된다. 즉, 프로그램 실행 중에 메모리를 동적으로 할당하지 않고, 컴파일 타임에 크기가 결정되며 스택 메모리에 할당.
그러나 동적 할당을 통해 구조체를 생성할 수도 있다. 이는 구조체 멤버 변수의 크기가 런타임에 결정되어야 하는 경우에 유용하고, 이를 위해 new 연산자를 사용하여 동적으로 구조체를 생성할 수 있다.
예를 들어,
    Point *p = new Point;
    p->x = 3;
    p->y = 4;

    delete p;
위 코드에서는 Point 구조체에 대한 포인터 p를 선언하고, new 연산자를 사용하여 동적으로 구조체를 할당한다. 그런 다음 포인터를 사용하여 구조체의 멤버 변수를 설정한다.
마지막으로 delete 연산자를 사용하여 구조체를 해제.

동적 할당은 메모리 관리 측면에서 복잡하며 실수로 할당 해제를 놓칠 수 있기 때문에, 가능하면 정적 할당을 사용하는 것이 좋다고 한다. 
(생각해보면 사용하는 예제를 고려해보니 값을 많이 받지 않을 것이기에 굳이 동적 할당을 할 필요가 없는 거 같기도함ㅋㅋ.)*/
